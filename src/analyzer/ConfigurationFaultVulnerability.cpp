/*
 * -----------------------------------------------------------------
 * COMPANY : Ruhr-Universit√§t Bochum, Chair for Security Engineering
 * AUTHOR  : Jakob Feldtkeller (jakob.feldtkeller@rub.de)
 *           Jan Richter-Brockmann (jan.richter-brockmann@rub.de)
 *           Pascal Sasdrich (pascal.sasdrich@rub.de)
 * DOCUMENT: --
 * -----------------------------------------------------------------
 *
 * Copyright (c) 2021, Pascal Sasdrich and Jan Richter-Brockmann and Jakob Feldtkeller
 *
 * All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTERS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Please see license.rtf and README for license and further instructions.
 */

#include "analyzer/ConfigurationFaultVulnerability.hpp"

void 
ConfigurationFaultVulnerability::initialize(const Settings *settings, State *state){
    m_bdd_input_is_secret = std::vector<int>();
    m_bdd_ouput_index = std::vector<int>();
    m_fia_vulnerability = 0;
    m_fault_selection = std::vector<std::map<const verica::Wire*, std::vector<BDD>>>(settings->getCores());
}

void get_secret_and_output(
            Cudd_Manager *mgr,
            std::vector<BDD> *function,
            std::vector<std::pair<int, bool>> *sat_assignment, 
            std::vector<int> *is_secret,
            std::vector<bool> *is_random,
            std::vector<int> *output_index,
            unsigned size_input, 
            int *out_vec,
            unsigned idx_out_vec,
            unsigned idx_sat_assignment,
            unsigned input_val,
            unsigned secret_val,
            std::vector<std::tuple<unsigned, unsigned, unsigned>> *result
){
    unsigned t_input_val, t_secret_val, t_output_val, t_idx_sat_assignment;
    /* If all inputs are consumed, get the output of the function via BDD */
    if(idx_out_vec == size_input){
        t_output_val = 0;
        for(unsigned idx=0; idx<function->size(); idx++){
            if(function->at(idx).Eval(out_vec) == mgr->bddOne()){
                /* Reverse order or output bits for consistency */
                // t_output_val ^= (1 << (function->size() - 1 - output_index->at(idx))); 
                t_output_val ^= (1 <<  output_index->at(idx)); 
            }
        }
        result->push_back(std::tuple<unsigned, unsigned, unsigned>(input_val, secret_val, t_output_val));
    /* If current input bit is NOT a don't care in the SAT then fix input accordingly */
    }else if(idx_sat_assignment < sat_assignment->size() 
                    && sat_assignment->at(idx_sat_assignment).first == idx_out_vec
    ){
        out_vec[idx_out_vec] = (int) sat_assignment->at(idx_sat_assignment).second;
        if(is_secret->at(idx_out_vec) >= 0){
            // t_secret_val = (secret_val << 1) | (out_vec[idx_out_vec] & 1);
            t_secret_val = secret_val ^ ((out_vec[idx_out_vec] & 1) << is_secret->at(idx_out_vec));
            t_input_val = input_val;
        } else if(is_random->at(idx_out_vec)) {
            t_input_val = input_val;
            t_secret_val = secret_val;
        } else {
            t_input_val = (input_val << 1) | (out_vec[idx_out_vec] & 1);
            t_secret_val = secret_val;
        }
        get_secret_and_output(
                    mgr, 
                    function, 
                    sat_assignment, 
                    is_secret, 
                    is_random, 
                    output_index,
                    size_input, 
                    out_vec, 
                    idx_out_vec+1, 
                    idx_sat_assignment+1, 
                    t_input_val, 
                    t_secret_val, 
                    result);
    /* Else, the input bit is an don't care in the SAT and we have to go through all possible assignments */
    }else{
        out_vec[idx_out_vec] = 0;
        t_idx_sat_assignment = idx_sat_assignment;
        if(is_secret->at(idx_out_vec) >= 0){
            // t_secret_val = (secret_val << 1);
            t_secret_val = secret_val; // CASE I: xor with 0
            t_input_val = input_val;
        } else if(is_random->at(idx_out_vec)) {
            t_input_val = input_val;
            t_secret_val = secret_val;
        }else{
            t_input_val = (input_val << 1);
            t_secret_val = secret_val;
        }
        get_secret_and_output(
                    mgr, 
                    function, 
                    sat_assignment, 
                    is_secret, 
                    is_random, 
                    output_index,
                    size_input, 
                    out_vec, 
                    idx_out_vec+1, 
                    t_idx_sat_assignment, 
                    t_input_val, 
                    t_secret_val, 
                    result);
        out_vec[idx_out_vec] = 1;
        if(is_secret->at(idx_out_vec) >= 0) t_secret_val = secret_val ^ ((out_vec[idx_out_vec] & 1) << is_secret->at(idx_out_vec));
        else if(!is_random->at(idx_out_vec)) t_input_val = t_input_val | 1;
        get_secret_and_output(
                    mgr, 
                    function, 
                    sat_assignment, 
                    is_secret, 
                    is_random, 
                    output_index,
                    size_input, 
                    out_vec, 
                    idx_out_vec+1, 
                    t_idx_sat_assignment, 
                    t_input_val, 
                    t_secret_val, 
                    result);
    }
}

double get_fault_probability(
            std::vector<std::pair<int, bool>> *sat_assignment, 
            unsigned size_inputs,
            unsigned size_faults, 
            int *fault_vec,
            unsigned idx_fault_vec,
            unsigned idx_sat_assignment,
            double rand_prob,
            std::vector<std::pair<double, int>> *fault_probability
){
    double prob = 1;
    double fault_prob = 0;
    /* Ensure index of SAT vector is set to a valid value */
    while(idx_sat_assignment < sat_assignment->size() 
                && sat_assignment->at(idx_sat_assignment).first < size_inputs) 
        idx_sat_assignment++; 
    /* Recursion is ended if all fault select signals are defined */
    if(idx_fault_vec == size_faults){
        unsigned idx_fault = 0;
        // unsigned idx_type = 0;
        /* Compute probability of this specific fault combination. The probability of a specific fault in a location is */
        /* the probability of a fault at this location divided by the number of faulty types for this gate. All fault   */
        /* locations are considered as independent (multiplication)                                                     */
        for(unsigned i=0; i<size_faults; i++){
            /* Compute fault probability at last location */
            if(fault_vec[i] == 1) /* Pr[fault occurs] */
                prob = (fault_probability->at(idx_fault).first/fault_probability->at(idx_fault).second)*prob;
            else /* Pr[fault occurs not] */
                prob = (1-fault_probability->at(idx_fault).first)*prob;
            /* Increment index of fault location */
            idx_fault++;
        }
        /* Return computed fault probability */
        return prob;
    }else if(idx_sat_assignment < sat_assignment->size() && 
                    sat_assignment->at(idx_sat_assignment).first == idx_fault_vec+size_inputs
    ){ /* Entry is specfied for this bit */
        /* Set value to specified bit */
        fault_vec[idx_fault_vec] = (int) sat_assignment->at(idx_sat_assignment).second;
        /* Go to next bit */
        fault_prob += get_fault_probability(
                    sat_assignment, 
                    size_inputs, 
                    size_faults, 
                    fault_vec, 
                    idx_fault_vec+1, 
                    idx_sat_assignment+1, 
                    rand_prob,
                    fault_probability);
    }else{  /* Entry is not specified for this bit */
        /* Enumerate all possible values for this bit */
        fault_vec[idx_fault_vec] = 0; /* Set entry to 0 */
        /* Go to next bit */
        fault_prob += get_fault_probability(
                    sat_assignment, 
                    size_inputs, 
                    size_faults, 
                    fault_vec, 
                    idx_fault_vec+1, 
                    idx_sat_assignment, 
                    rand_prob,
                    fault_probability);
        fault_vec[idx_fault_vec] = 1; /* Set entry to 1 */
        /* Go to next bit */
        fault_prob += get_fault_probability(
                    sat_assignment, 
                    size_inputs, 
                    size_faults, 
                    fault_vec, 
                    idx_fault_vec+1, 
                    idx_sat_assignment, 
                    rand_prob,
                    fault_probability);
    }
    /* Return computed fault probability */
    return fault_prob;
}

void ConfigurationFaultVulnerability::execute(const Settings *settings, State *state) {
    /* Get number of cores for parallel computation */
    unsigned num_cores = settings->getCores();
    /* Get shape of the module under test (input/output) */
    unsigned num_inputs = state->m_netlist_model->module_under_test()->input_pins().size();
    unsigned num_outputs = state->m_netlist_model->module_under_test()->output_pins().size();
    /* Define variables for computation */
    unsigned sat_vector_idx, sat_value_idx, num_faulty_outputs;
    unsigned num_secrets = 0;
    unsigned num_rand = 0;
    unsigned num_unshared_outputs = 0;
    double prob_rand = 1;
    /* Prepare for estimator */
    bool estimator = settings->getFaultVulnerabilityEstimator();
    unsigned num_tries_estimator = settings->getFaultVulnerabilityEstimatorRuns(); 
    double z_score = 1.96;  /* Z score for computation of 95% confidence interval */
    double mean = 0;
    double mean_temp;
    double variance = 0;
    double sample_size = 0;
    std::srand((unsigned) std::chrono::high_resolution_clock::now().time_since_epoch().count()); 
    /* Set the number of runs to the number of possible output values or to the specified number of runs */
    if(!estimator) num_faulty_outputs = pow(2,num_outputs); /* Deterministic mode */
    else num_faulty_outputs = num_tries_estimator;          /* Probabilistic mode*/

     /* Initialize two vectors that indicates which BDD variables are secrets and which are randomness */
    m_bdd_input_is_secret.resize(num_inputs, -1);
    m_bdd_input_is_random.resize(num_inputs, false);
    std::set<int> secret_index_set;
    for(auto p: state->m_netlist_model->module_under_test()->input_pins()){
        /* Get index of BDD variable of current input pin -> input has only one variable in support */
        int index = p->fan_out()->golden_functions(0).SupportIndices()[0];
        if(p->secret_index() >= 0){
            /* Update position of secret inputs */
            secret_index_set.insert(p->secret_index());
            m_bdd_input_is_secret[index] = p->secret_index();
        }
        else if(p->port_type() == verica::Refresh){
            /* Update postion of random inputs */
            m_bdd_input_is_random[index] = true;
            num_rand++; /* Count number of random input variables */
        }
    }
    /* Get the number of secrets */
    num_secrets = secret_index_set.size();

    /* Get indices of outputs */
    m_bdd_ouput_index.resize(num_outputs, -1);
    std::set<int> output_index_set;
    for(unsigned idx=0; idx<num_outputs; idx++){
        const verica::Pin* p = state->m_netlist_model->module_under_test()->output_pins().at(idx);
        int share_index = p->share_index();
        /* If no share index is given or output unsharing is disabled assume unshared outputs in provided order*/
        if(share_index == -1 || !settings->getFaultVulnerabilityUnshareOutputs()) share_index = idx;
        m_bdd_ouput_index[idx] = share_index;
        output_index_set.insert(share_index);
    }
    /* Get the number of outputs (after unsharing if necessary)*/
    num_unshared_outputs = output_index_set.size();
    /* Compute the number of inputs that are neither secret nor random */
    unsigned num_non_secret = num_inputs - num_secrets - num_rand;
    /* Compute the probabilities of secrets, inputs, and randomness (under uniform distribution) */
    double input_prob = 1 / pow(2, num_non_secret);
    double secret_prob = 1 / pow(2, num_secrets);
    if(num_rand != 0) prob_rand = 1 / pow(2, num_rand);
    /* Get the current number of BDD variables, which will be the start index for fault select variables */
    unsigned idx_start_fault_select = state->m_managers[0].ReadSize();

    /* Initialize a vector with all golden output functions and add MUXes for each possible fault */
    std::vector<std::vector<BDD>> golden_output = std::vector<std::vector<BDD>>(num_cores);
    #pragma omp parallel num_threads(num_cores) 
    #pragma omp for schedule(dynamic)
    for(unsigned core=0; core<num_cores; core++){ /*Parallel computation */
        for(auto out: state->m_netlist_model->module_under_test()->output_pins()){
            golden_output[core].push_back(out->fan_in()->golden_functions(core));
        }
        /* Add selector signals and MUXes for each possible fault */
        m_injector[core]->add_fault_select(m_fault_selection[core], core);
    }
    /* Get the number of fault select variables */
    unsigned size_fault_select = state->m_managers[0].ReadSize() - idx_start_fault_select;

    /* Construct a BDD that restricts the number of faults to one per gate */
    std::vector<BDD> one_fault_bdd = std::vector<BDD>(num_cores); 
    #pragma omp parallel num_threads(num_cores) 
    #pragma omp for schedule(dynamic)
    for(unsigned core=0; core<num_cores; core++){ /* Parallel computation*/
        /* Get current BDD manager */
        Cudd_Manager mgr = state->m_managers[core];
        /* Start construction with a constant one */
        one_fault_bdd[core] = mgr.bddOne();
        /* Define temporary BDD variables */
        BDD same_location_bdd;
        BDD clause_bdd;
        /* Create an AND of BDDs for each individual fault location */
        for(auto fault_location: state->m_faultLocations){
            same_location_bdd = mgr.bddZero();
            if(m_fault_selection[core][fault_location].size() == 1){
                /* If only one fault type for this location is allowed, the    */
                /* clause for this location is just the related select signal. */
                same_location_bdd = mgr.bddOne();
            }else{
                /* For multiple fault types create clauses, where exactly one fault select */
                /* signal is true and all others are false, for all select signals.        */
                for(int neg=0; neg<m_fault_selection[core][fault_location].size(); neg++){
                    clause_bdd = mgr.bddOne();
                    for(int idx=0; idx<m_fault_selection[core][fault_location].size(); idx++){
                        if(neg == idx) clause_bdd &= !m_fault_selection[core][fault_location].at(idx);
                        else clause_bdd &= m_fault_selection[core][fault_location].at(idx);
                    }
                    same_location_bdd |= clause_bdd;
                } 
                /* In addition, allow that no fault in a location is selected */
                clause_bdd = mgr.bddOne();
                for(int idx=0; idx<m_fault_selection[core][fault_location].size(); idx++){
                    clause_bdd &= !m_fault_selection[core][fault_location].at(idx);
                }  
                same_location_bdd ^= clause_bdd;
            }
            /* Construct AND of BDDs of individual fault locations */
            one_fault_bdd[core] &= same_location_bdd; 
        }   
    }
    /* Create a vector where the index corresponds to the index of a fault location    */
    /* and the entry indicates the corresponding fault probability and number of fault */
    /* select variables for that location                                               */
    std::vector<std::pair<double, int>> fault_probability_vec;
    for(auto fault_location: state->m_faultLocations){
        /* Distinguish between faults at inputs and faults at gates */
        if(fault_location->faulty_gate_identifier(0) == 10){
            /* Faults at inputs */
            std::pair<double, int> pair(
                        fault_location->fia_probability(), 
                        m_fault_selection[0][fault_location].size());
            fault_probability_vec.push_back(pair);
        }else{
            /* Faults at gates */
            std::pair<double, int> pair(
                        fault_location->source_pin()->parent_module()->fia_probability(), 
                        m_fault_selection[0][fault_location].size());
            fault_probability_vec.push_back(pair);
        }
    }
    

    /* Compute FIA vulnerability as sum of vulnerability for each ouput value */
    #pragma omp parallel num_threads(settings->getCores())
    {
    #pragma omp for schedule(dynamic) 
    for(unsigned idx_faulty_output_val=0; idx_faulty_output_val<num_faulty_outputs; idx_faulty_output_val++){ /* Parallel computation */
        /* Get thread number */
        int core = omp_get_thread_num(); 
        /* Get BDD manager of current thread */
        Cudd_Manager mgr = state->m_managers[core];
        /* Define computational variables for this thread */
        bool last;
        unsigned input_val, secret_val, output_val, faulty_out_val, correct_out_val;
        double fault_prob;
        double this_val = 0;
        BDD faulty_output, correct_output, pin;
        std::map<unsigned, double> max_prob;
        std::map<unsigned, std::map<unsigned, double>> prob_list;
        std::vector<std::vector<std::pair<int, bool>>> sat;
        std::vector<std::pair<int, bool>> *current_input;
        std::vector<std::tuple<unsigned, unsigned, unsigned>> input_output_relation = std::vector<std::tuple<unsigned, unsigned, unsigned>>();
        int *out_vec = new int[state->m_managers[core].ReadSize()]();
        int *fault_vec = new int[size_fault_select]();
        /* Current faulty output value y' is either the index of loop or some random number */
        if(!estimator) faulty_out_val = idx_faulty_output_val;              /* Deterministic mode */
        else faulty_out_val = std::rand() % (unsigned)pow(2,num_outputs);   /* Probabilistic mode */
        /* Create BDD of the circuit where the output is the current faulty output value y' and at most one fault is allowed per fault location */
        faulty_output = one_fault_bdd[core];    /* Start with BDD that allows one fault per location*/
        for(unsigned idx=0; idx<num_outputs; idx++){
            /* Fix each output pin to the corresponding bit in the binary representation of the faulty output value y'*/
            pin = state->m_netlist_model->module_under_test()->output_pins().at(idx)->fan_in()->faulty_functions(core);
            if(faulty_out_val & (1 << (num_outputs - idx -1))){
                faulty_output &= pin;
            }else{
                faulty_output &= !pin;
            }
        }
        /* Get the satisfying assignment for this faulty output y'. */
        /* This gives valid assignments for inputs and faults.       */
        mgr.bdd_sat(faulty_output, sat);
        /* Get the maximum key dependent probabilities for this faulty output y' */
        sat_value_idx = 0;
        fault_prob = 0;
        if(sat.size() > 0) current_input = &sat.at(0);
        for(unsigned sat_vector_idx=0; sat_vector_idx<sat.size(); sat_vector_idx++){
            /* Determine the input given by the SAT solving at the current index.            */
            /* Determine whether there is another entry with this input but different fault. */
            last = false;
            if(sat_vector_idx == sat.size()-1){
                last = true;
            }else{
                for(unsigned idx=0; idx<sat.at(sat_vector_idx+1).size(); idx++){
                    if(sat.at(sat_vector_idx+1).at(idx).first < num_inputs){
                        if(!(sat.at(sat_vector_idx+1).at(idx).first == current_input->at(idx).first &&
                            sat.at(sat_vector_idx+1).at(idx).second == current_input->at(idx).second))
                        {
                            current_input = &sat.at(sat_vector_idx+1);
                            last = true;
                            break;
                        }
                    } else if(sat.at(sat_vector_idx+1).at(idx).first == num_inputs){
                        break;
                    }
                }
            }
            /* Sum up all fault probabilities of same inputs */
            fault_prob += get_fault_probability(
                        &sat.at(sat_vector_idx),
                        idx_start_fault_select, 
                        size_fault_select, 
                        fault_vec, 
                        0, 
                        0, 
                        prob_rand, 
                        &fault_probability_vec);  
            /* Compute maximum key dependent probability for this input */
            if(last){
                /* Get all relations of non-secrets inputs, secret, and non-faulty output for current iteration. */
                /* Resolving all don't care assignments by enumerating all possible values.                      */
                get_secret_and_output(
                            &mgr, 
                            &golden_output[core], 
                            &sat.at(sat_vector_idx), 
                            &m_bdd_input_is_secret, 
                            &m_bdd_input_is_random, 
                            &m_bdd_ouput_index,
                            num_inputs, 
                            out_vec, 
                            0, 
                            0, 
                            0, 
                            0, 
                            &input_output_relation);
                /* Go though all values and select maximum key dependent probability for each output y (non-faulty) */
                for(auto t: input_output_relation){
                    std::tie(input_val, secret_val, output_val) = t;
                    if(prob_list.count(output_val)){ /* There is already list for this non-faulty output y in the list */
                        if(prob_list[output_val].count(secret_val)){ /* There is already a probability for this non-faulty output and secret */
                            /* Add all probabilities of for same non-faulty output and secret. */
                            prob_list[output_val][secret_val] += fault_prob * input_prob * prob_rand;   
                            /* Update maximum list for this non-faulty output y if necessary */
                            if(max_prob[output_val] < prob_list[output_val][secret_val]){
                                max_prob[output_val] = prob_list[output_val][secret_val];
                            }
                        }else{ /* There is no probability for this non-faulty output and secret */
                            /* Create a new entry indexed with the non-faulty output y and the secret */
                            prob_list[output_val][secret_val] = fault_prob * input_prob * prob_rand;
                            /* Update maximum list for this non-faulty output y if necessary */
                            if(!max_prob.count(output_val) || max_prob[output_val] < prob_list[output_val][secret_val]){
                                max_prob[output_val] = prob_list[output_val][secret_val];
                            }
                        }
                    } else {    /* There is no list for the non-faulty output y in the list */
                        /* Create a new entry indexed with the non-faulty output y and the secret */
                        prob_list[output_val][secret_val] = fault_prob * input_prob * prob_rand;
                        /* Update maximum list for this non-faulty output y if necessary */
                        if(!max_prob.count(output_val) || max_prob[output_val] < prob_list[output_val][secret_val]){
                            max_prob[output_val] = prob_list[output_val][secret_val];
                        }
                    }
                }
                /* Clear temporal memory */
                fault_prob = 0;
                input_output_relation.clear();
            } 
        }
        /* Add up all max values for vulnerability */
        for(auto const& max: max_prob){
            this_val += (double)max.second * secret_prob;
        }
        #pragma omp atomic
        sample_size += 1;
        /* Iterative computation of mean an variance */
        if(estimator){
            #pragma omp critical (variance_computation)
            {
                mean_temp = mean;
                mean += (this_val - mean)/sample_size;
                variance += (this_val - mean_temp)*(this_val - mean);
            }
        }
        /* Add up vulnerabilities */
        #pragma omp atomic
        m_fia_vulnerability += this_val;
        
        /* Clear temporal memory */
        prob_list.clear();
        max_prob.clear(); 

        /* Progress */
        m_logger->progress(sample_size, num_faulty_outputs);
    }         
    }    
    /* For estimation the vulnerability needs to be scaled to number of actual output values */
    if(estimator){        
        m_fia_vulnerability = m_fia_vulnerability/num_faulty_outputs*pow(2,num_outputs);
    }
    /* Compute min entropy and leakage */
    m_fia_min_entropy = log2(1.0/m_fia_vulnerability);
    m_fia_leakage = num_secrets - m_fia_min_entropy;
    /* Compute confidence level for each value */
    variance = variance/num_faulty_outputs;
    m_fia_vulnerability_ci_low = (mean - z_score*sqrt(variance/(double)num_faulty_outputs))*pow(2,num_outputs);
    m_fia_vulnerability_ci_high = (mean + z_score*sqrt(variance/(double)num_faulty_outputs))*pow(2,num_outputs);
    m_fia_min_entropy_ci_low = log2(1.0/m_fia_vulnerability_ci_high);
    m_fia_min_entropy_ci_high = log2(1.0/m_fia_vulnerability_ci_low);
    m_fia_leakage_ci_low = num_secrets - m_fia_min_entropy_ci_high;
    m_fia_leakage_ci_high = num_secrets - m_fia_min_entropy_ci_low;
}


void
ConfigurationFaultVulnerability::report(std::string service, const Logger *logger, const Settings *settings, State *state) const
{    
    /* Print header */
    logger->header("ANALYSIS REPORT");

    if(settings->getFaultVulnerabilityEstimator()){
        logger->log(service, "FIA Vulnerability: " + std::to_string(m_fia_vulnerability) + "     CI(95%): [" + std::to_string(m_fia_vulnerability_ci_low) + ", " + std::to_string(m_fia_vulnerability_ci_high) + "]");
        logger->log(service, "FIA Min-Entropy:   " + std::to_string(m_fia_min_entropy) + "     CI(95%): [" + std::to_string(m_fia_min_entropy_ci_low) + ", " + std::to_string(m_fia_min_entropy_ci_high) + "]");
        logger->log(service, "FIA Leakage:       " + std::to_string(m_fia_leakage) + " Bit" + " CI(95%): [" + std::to_string(m_fia_leakage_ci_low) + ", " + std::to_string(m_fia_leakage_ci_high) + "]");
    }else{
        logger->log(service, "FIA Vulnerability: " + std::to_string(m_fia_vulnerability));
        logger->log(service, "FIA Min-Entropy:   " + std::to_string(m_fia_min_entropy));
        logger->log(service, "FIA Leakage:       " + std::to_string(m_fia_leakage) + " Bit");
    }

    /* Print footer */
    if (true)
        logger->footer(service, this->m_name, SUCCESS);
    else
        logger->footer(service, this->m_name, FAILURE);
}

void
ConfigurationFaultVulnerability::finalize(const Settings *settings, State *state) {
}